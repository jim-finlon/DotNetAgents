# DotNetAgents Library - Cursor Rules

## Project Overview
This is an enterprise-grade, open-source .NET 10 library that replicates LangChain and LangGraph functionality in C#. The project targets .NET developers building agentic AI systems. Built on .NET 10 (LTS) to leverage AI optimizations and Microsoft Agent Framework compatibility.

**Current Status:** Production-ready beta with comprehensive plugin architecture, multi-agent patterns, observability, and enterprise features.

## Core Principles

### 1. Quality First
- Write production-ready code from day one
- No shortcuts or technical debt
- Comprehensive error handling
- Defensive programming practices
- All public APIs must be well-documented
- Minimum 85% test coverage for all projects

### 2. Architecture
- **Modular Design**: Code is structured as separate projects (Core, Providers, Workflow, Ecosystem, etc.)
- **Plugin Architecture**: Extensible plugin system with automatic discovery, dependency resolution, and lifecycle management
- **Dependency Inversion**: Core has ZERO dependencies on integrations
- **Interface-Based**: Prefer interfaces over concrete implementations
- **SOLID Principles**: Strictly follow SOLID principles
- **Separation of Concerns**: Clear boundaries between layers
- **Provider Pattern**: Use provider pattern for different implementations (databases, message buses, LLMs)

### 3. .NET 10 & C# 13 Standards
- Target .NET 10 (LTS) - **Version 10.0.0** for all Microsoft.Extensions.* packages
- Use C# 13 features where appropriate
- **Nullable Reference Types**: Always enabled, use `?` and `!` appropriately
- **Records**: Use records for immutable data types (DTOs, state objects, configuration)
- **Pattern Matching**: Use pattern matching where it improves readability
- **File-Scoped Namespaces**: Use file-scoped namespaces (`namespace DotNetAgents.Core;`)
- **Collection Expressions**: Use `[item1, item2]` syntax for collections
- **Primary Constructors**: Use for DTOs and simple classes where appropriate

## Coding Standards

### Naming Conventions
- **Interfaces**: Start with `I` (e.g., `ILLMModel`, `IPromptTemplate`, `IPlugin`)
- **Classes**: PascalCase (e.g., `PromptTemplate`, `GraphExecutor`, `PluginBase`)
- **Methods**: PascalCase (e.g., `GenerateAsync`, `ExecuteAsync`, `InitializeAsync`)
- **Parameters**: camelCase (e.g., `cancellationToken`, `input`, `pluginContext`)
- **Private Fields**: `_camelCase` with underscore prefix
- **Constants**: `PascalCase` (e.g., `MaxRetries`, `DefaultTimeout`)
- **Async Methods**: Always end with `Async` suffix
- **Plugin Classes**: End with `Plugin` (e.g., `StateMachinesPlugin`, `OpenAIProviderPlugin`)

### Code Style
- Use 4 spaces for indentation (not tabs)
- Maximum line length: 120 characters
- Use `var` only when type is obvious from right-hand side
- Prefer explicit types for public APIs
- Use expression-bodied members when appropriate
- Use `nameof()` instead of string literals for property/parameter names
- Use collection expressions: `var list = [item1, item2];` instead of `new List<T> { item1, item2 }`

### Async/Await Patterns
- **Always** use `async`/`await`, never use `.Result` or `.Wait()`
- **Always** accept `CancellationToken` in async methods (except entry points where it's optional)
- Use `IAsyncEnumerable<T>` for streaming operations
- Use `ConfigureAwait(false)` in library code (not in application code)
- Handle cancellation gracefully with `OperationCanceledException`
- Use `ValueTask<T>` for hot paths that may complete synchronously

### Error Handling
- Use specific exception types (`AgentException`, `LLMException`, `PluginException`, etc.)
- Include correlation IDs in exceptions for tracing
- Never swallow exceptions silently
- Log exceptions before rethrowing
- Use `throw;` (not `throw ex;`) to preserve stack trace
- Use `Exception.Data` for additional context

### Null Safety
- Use nullable reference types throughout
- Mark nullable parameters with `?`
- Use null-forgiving operator `!` only when absolutely certain
- Use null-conditional operators (`?.`, `??`) appropriately
- Validate null inputs in public methods using `ArgumentNullException.ThrowIfNull()`

## Project Structure Guidelines

### Package Architecture
- **Core Package** (`DotNetAgents.Core`): Zero dependencies on integrations
- **Abstractions Package** (`DotNetAgents.Abstractions`): Core interfaces and contracts
- **Ecosystem Package** (`DotNetAgents.Ecosystem`): Plugin system infrastructure
- **Provider Packages**: Each provider in separate project (OpenAI, Azure, Anthropic, etc.)
- **Feature Packages**: Agent capabilities as plugins (StateMachines, BehaviorTrees, Swarm, etc.)
- **Infrastructure Packages**: Storage, Vector Stores, Message Buses (registered as plugins)
- **Metapackage** (`DotNetAgents`): References all packages for convenience
- Follow dependency inversion principle strictly

### Plugin Architecture Patterns

#### Creating a Plugin
```csharp
using DotNetAgents.Ecosystem;

public class MyFeaturePlugin : PluginBase
{
    public MyFeaturePlugin()
    {
        Metadata = new PluginMetadata
        {
            Id = "myfeature",
            Name = "My Feature",
            Version = "1.0.0",
            Description = "Description of my feature",
            Author = "Your Name",
            License = "MIT",
            Dependencies = new List<string> { "core" },
            MinimumCoreVersion = "1.0.0"
        };
    }

    protected override Task OnInitializeAsync(IPluginContext context, CancellationToken cancellationToken)
    {
        Logger?.LogInformation("My Feature plugin initialized");
        return Task.CompletedTask;
    }

    protected override Task OnShutdownAsync(CancellationToken cancellationToken)
    {
        Logger?.LogInformation("My Feature plugin shutting down");
        return Task.CompletedTask;
    }
}
```

#### Registering a Plugin
```csharp
// In ServiceCollectionExtensions.cs
public static IServiceCollection AddMyFeature(this IServiceCollection services)
{
    ArgumentNullException.ThrowIfNull(services);
    services.AddPlugin(new MyFeaturePlugin());
    // Register services...
    return services;
}
```

#### Plugin Discovery
- Plugins are automatically discovered when `EnablePluginDiscovery()` is called
- Plugins must inherit from `PluginBase` or implement `IPluginWithMetadata`
- Dependencies are automatically resolved and plugins initialized in correct order

### File Organization
- One public type per file (except related types like exceptions)
- File name matches class/interface name
- Group related files in folders by feature/domain
- Use `Directory.Build.props` for shared properties
- Plugin files: `{FeatureName}Plugin.cs`

### Namespace Organization
```
DotNetAgents.Core.{Feature}
DotNetAgents.Abstractions.{Feature}
DotNetAgents.Ecosystem
DotNetAgents.Providers.{ProviderName}
DotNetAgents.Agents.{Capability}          // Agent capabilities (plugins)
DotNetAgents.Agents.Messaging.{BusType}   // Message bus implementations (plugins)
DotNetAgents.Workflow.{Feature}
DotNetAgents.Configuration
DotNetAgents.Observability.{Feature}
DotNetAgents.Security.{Feature}
DotNetAgents.Storage.{Type}
DotNetAgents.VectorStores.{StoreType}
```

## API Design Guidelines

### Public APIs
- Design for extensibility and testability
- Use interfaces for all public contracts
- Prefer composition over inheritance
- Make APIs discoverable and intuitive
- Provide fluent APIs where appropriate
- Support dependency injection throughout

### Method Signatures
- Keep parameter lists short (max 5-6 parameters)
- Use options objects for complex configurations
- Provide sensible defaults
- Use overloads for convenience methods
- Always include XML documentation comments
- Use `CancellationToken` as the last parameter

### Example:
```csharp
/// <summary>
/// Generates a response using the LLM model.
/// </summary>
/// <param name="input">The input to process.</param>
/// <param name="options">Optional configuration for the generation.</param>
/// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
/// <returns>The generated output.</returns>
/// <exception cref="AgentException">Thrown when generation fails.</exception>
public Task<TOutput> GenerateAsync(
    TInput input,
    LLMOptions? options = null,
    CancellationToken cancellationToken = default);
```

## Dependency Injection

### Registration
- Use `Microsoft.Extensions.DependencyInjection` (Version 10.0.0)
- Register interfaces, not concrete types
- Use extension methods for service registration (`AddDotNetAgents()`, `AddOpenAI()`, etc.)
- Support both `IServiceCollection` and `IHostBuilder`
- Always call `ArgumentNullException.ThrowIfNull(services)` in extension methods

### Lifetime Management
- **Singleton**: For stateless services (factories, configuration, plugin registry)
- **Scoped**: For request-scoped services (execution context, workflow state)
- **Transient**: For services that should be created fresh each time

### Example:
```csharp
public static IServiceCollection AddDotNetAgents(
    this IServiceCollection services,
    Action<AgentConfiguration>? configure = null)
{
    ArgumentNullException.ThrowIfNull(services);
    services.AddSingleton<ILLMModelFactory, LLMModelFactory>();
    services.AddScoped<IExecutionContextProvider, ExecutionContextProvider>();
    return services;
}
```

## Plugin System Guidelines

### Plugin Development
- All plugins must inherit from `PluginBase` or implement `IPluginWithMetadata`
- Provide complete `PluginMetadata` including dependencies
- Implement `OnInitializeAsync` and `OnShutdownAsync` for lifecycle management
- Use `IPluginContext` to access services, configuration, and logging
- Register plugin in `ServiceCollectionExtensions` using `services.AddPlugin()`

### Plugin Categories
- **Agent Capabilities**: StateMachines, BehaviorTrees, Swarm, Hierarchical, Marketplace
- **Infrastructure**: Message Buses (Kafka, RabbitMQ, Redis, SignalR), Storage, Vector Stores
- **Providers**: LLM providers (OpenAI, Azure, Anthropic, etc.)
- **Integrations**: MCP, Edge computing

### Plugin Dependencies
- Declare dependencies in `PluginMetadata.Dependencies`
- Dependencies are automatically resolved
- Plugins are initialized in dependency order
- Circular dependencies are detected and reported

## Multi-Agent Patterns

### Supervisor-Worker Pattern
- Use `ISupervisorAgent` for task delegation
- Use `IWorkerPool` for worker management
- Use `IAgentRegistry` for agent registration
- Support state machines for agent lifecycle
- Support behavior trees for intelligent routing

### Swarm Intelligence
- Use `SwarmCoordinator` for swarm-based coordination
- Support multiple strategies: ParticleSwarm, AntColony, Flocking, Consensus
- Track fitness scores and pheromone trails
- Enable dynamic agent addition/removal

### Hierarchical Organizations
- Use `HierarchicalAgentOrganization` for team structures
- Support teams, departments, and organizations
- Enable delegation through hierarchy
- Track organizational metrics

### Agent Marketplace
- Use `AgentMarketplace` for agent discovery
- Support capability-based matching
- Enable dynamic agent registration
- Track agent ratings and availability

## Testing Standards

### Test Coverage
- **Minimum 85% code coverage** for all projects
- Test all public APIs
- Test error paths and edge cases
- Test async/await patterns
- Test cancellation scenarios
- Test plugin lifecycle (initialization, shutdown)
- Test multi-agent coordination patterns

### Test Organization
- One test class per class/interface being tested
- Use descriptive test method names: `MethodName_Scenario_ExpectedResult`
- Use `[Fact]` for xUnit tests
- Use `[Theory]` with `[InlineData]` for parameterized tests
- Group related tests with `#region`
- Use `Testcontainers` for integration tests with real databases/services

### Test Patterns
- Use `Moq` for mocking dependencies
- Use `FluentAssertions` for assertions
- Use `IAsyncDisposable` for test cleanup
- Use test data builders for complex objects
- Create contract test base classes for interfaces
- Test plugin discovery and initialization

### Example:
```csharp
public class PromptTemplateTests
{
    [Fact]
    public async Task FormatAsync_WithValidVariables_ReturnsFormattedString()
    {
        // Arrange
        var template = new PromptTemplate("Hello {name}!");
        var variables = new Dictionary<string, object> { ["name"] = "World" };
        
        // Act
        var result = await template.FormatAsync(variables);
        
        // Assert
        result.Should().Be("Hello World!");
    }
    
    [Fact]
    public async Task FormatAsync_WithMissingVariable_ThrowsException()
    {
        // Arrange
        var template = new PromptTemplate("Hello {name}!");
        var variables = new Dictionary<string, object>();
        
        // Act & Assert
        await Assert.ThrowsAsync<ArgumentException>(
            () => template.FormatAsync(variables));
    }
}
```

## Documentation Standards

### XML Documentation
- **All public APIs** must have XML documentation comments
- Include `<summary>`, `<param>`, `<returns>`, `<exception>` tags
- Use `<see cref="">` for type references
- Use `<seealso cref="">` for related APIs
- Include code examples in `<example>` tags for complex APIs
- Document plugin metadata and dependencies

### README Files
- Each project should have a README.md
- Include purpose, usage examples, and key APIs
- Link to main documentation
- Document plugin registration and configuration

### Code Comments
- Use comments to explain "why", not "what"
- Avoid obvious comments
- Use `// TODO:` for planned improvements
- Use `// NOTE:` for important implementation details
- Remove commented-out code before committing

## Security Best Practices

### Secrets Management
- **Never** hardcode API keys or secrets
- Use `ISecretsProvider` for all secret access
- Support Azure Key Vault, AWS Secrets Manager, environment variables
- Validate secrets at startup, not at runtime
- Rotate secrets regularly

### Input Validation
- Validate all inputs in public methods
- Use `ISanitizer` for input sanitization
- Detect prompt injection attempts
- Validate tool inputs against schemas
- Use `ArgumentNullException.ThrowIfNull()` for null checks
- Validate plugin metadata and dependencies

### Data Protection
- Encrypt sensitive data at rest
- Use TLS 1.2+ for all external calls
- Mask PII in logs
- Never log secrets or API keys
- Use secure credential storage
- Implement rate limiting for API calls

### Plugin Security
- Validate plugin signatures (if implemented)
- Sandbox plugin execution (if needed)
- Audit plugin access to resources
- Implement plugin permission system

## Performance Guidelines

### Async Operations
- Use `async`/`await` throughout
- Avoid blocking calls (`Task.Result`, `.Wait()`)
- Use `IAsyncEnumerable<T>` for streaming
- Batch operations when possible
- Use `ConfigureAwait(false)` in library code
- Use `ValueTask<T>` for hot paths

### Caching
- Cache embeddings and LLM responses when appropriate
- Use multi-level caching (memory, distributed, persistent)
- Implement cache invalidation strategies
- Monitor cache hit rates
- Cache plugin metadata and discovery results

### Resource Management
- Implement `IDisposable` or `IAsyncDisposable` for resources
- Use `using` statements or `await using` for disposal
- Pool HTTP clients via `IHttpClientFactory`
- Avoid memory leaks (event handlers, timers, etc.)
- Dispose plugin resources in `OnShutdownAsync`

### Optimization
- Profile before optimizing
- Use `Span<T>` and `Memory<T>` for zero-allocation scenarios
- Avoid premature optimization
- Measure performance with benchmarks
- Document performance characteristics
- Leverage .NET 10 AI optimizations

## Observability Standards

### Structured Logging
- Use `Microsoft.Extensions.Logging` (Version 10.0.0)
- Use structured logging (parameters, not string interpolation)
- Include correlation IDs in logs
- Use appropriate log levels:
  - `Trace`: Very detailed, for debugging
  - `Debug`: Detailed information for debugging
  - `Information`: General information
  - `Warning`: Warning messages
  - `Error`: Error messages
  - `Critical`: Critical failures

### Distributed Tracing
- Use OpenTelemetry for distributed tracing
- Propagate correlation IDs across service boundaries
- Include trace context in all external calls
- Instrument plugin initialization and lifecycle

### Metrics
- Use OpenTelemetry metrics
- Track plugin registration and initialization times
- Monitor agent performance and coordination
- Track LLM call costs and performance
- Export to Prometheus for monitoring

### Example:
```csharp
_logger.LogInformation(
    "LLM call completed. Model: {ModelName}, Tokens: {TokenCount}, Duration: {Duration}ms",
    modelName,
    tokenCount,
    duration.TotalMilliseconds);
```

## Error Handling Patterns

### Exception Types
- Create specific exception types (`AgentException`, `LLMException`, `PluginException`, etc.)
- Include correlation IDs for tracing
- Include context in exception messages
- Use `Exception.Data` for additional context
- Create exception hierarchies for related errors

### Retry Logic
- Implement retry with exponential backoff
- Use `Polly` for complex retry scenarios
- Respect `CancellationToken` in retry loops
- Log retry attempts
- Make retry policies configurable

### Circuit Breaker
- Implement circuit breaker for external calls
- Track failure rates
- Provide fallback mechanisms when possible
- Integrate with observability for monitoring

### Plugin Error Handling
- Handle plugin initialization failures gracefully
- Log plugin errors with context
- Support plugin error recovery
- Report plugin errors to observability

## Workflow and State Management

### Workflow Design
- State must be serializable (for checkpointing)
- Support checkpointing for long-running workflows
- Handle cancellation properly
- Provide fluent API for graph building
- Support conditional edges and human-in-the-loop

### State Machines
- Use state machines for agent lifecycle management
- Support hierarchical, parallel, and timed transitions
- Implement guards for state transitions
- Support state machine patterns (supervisor, worker, etc.)

### Behavior Trees
- Use behavior trees for autonomous decision-making
- Support composite, decorator, and action nodes
- Integrate with agent registry and worker pool
- Support dynamic tree modification

## Open Source Best Practices

### Code Quality
- Follow all coding standards strictly
- Write self-documenting code
- Keep functions small and focused
- Avoid magic numbers (use constants)
- Use meaningful variable names
- Refactor regularly to maintain quality

### Git Practices
- Write clear, descriptive commit messages
- Use conventional commits format: `type(scope): description`
- Types: `feat`, `fix`, `docs`, `test`, `refactor`, `perf`, `chore`, `plugin`
- Keep commits focused (one logical change per commit)
- Create meaningful branch names
- Use feature branches for new work

### Pull Requests
- Keep PRs focused and small
- Include tests for new features
- Update documentation
- Request reviews from maintainers
- Address all review comments
- Test plugin changes thoroughly

## Specific Project Guidelines

### Core Package Rules
- **ZERO dependencies** on provider packages
- All interfaces defined in Abstractions
- No concrete implementations of providers in Core
- Use dependency inversion throughout
- Support plugin system via Ecosystem package

### Provider Package Rules
- Each provider in separate project
- Depend only on Core/Abstractions packages
- Implement Core interfaces
- Provide extension methods for DI registration
- Include provider-specific tests
- Register as plugin using `AddPlugin()`

### Plugin Package Rules
- Inherit from `PluginBase`
- Provide complete metadata
- Declare dependencies
- Implement lifecycle methods
- Register in `ServiceCollectionExtensions`
- Include plugin-specific tests

### Workflow Package Rules
- Depends on Core
- State must be serializable
- Support checkpointing
- Handle cancellation properly
- Provide fluent API for graph building
- Integrate with observability

### Configuration Rules
- Support multiple configuration sources
- Validate configuration at startup
- Provide fluent builder API
- Support environment-specific configs
- Document all configuration options
- Support plugin configuration

## Code Review Checklist

Before submitting code, ensure:
- [ ] All tests pass
- [ ] Code coverage meets 85% minimum
- [ ] XML documentation complete
- [ ] No hardcoded secrets
- [ ] Error handling implemented
- [ ] Cancellation tokens used
- [ ] Async/await used correctly
- [ ] Nullable reference types handled
- [ ] No compiler warnings
- [ ] Code follows style guidelines
- [ ] Performance considered
- [ ] Security reviewed
- [ ] Plugin lifecycle handled (if applicable)
- [ ] Observability integrated
- [ ] Dependencies declared (for plugins)

## Tools and Analyzers

### Required Analyzers
- StyleCop.Analyzers
- Microsoft.CodeAnalysis.NetAnalyzers
- Nullable reference type warnings enabled
- Treat warnings as errors in release builds

### Required Package Versions
- `Microsoft.Extensions.*`: Version 10.0.0
- `System.Text.Json`: Version 10.0.0
- Target Framework: .NET 10.0

### Recommended Tools
- JetBrains ReSharper / Rider
- SonarLint
- .NET Code Formatter
- BenchmarkDotNet for performance testing
- Testcontainers for integration tests

## Examples of Good Code

### Good: Plugin Implementation
```csharp
public class MyFeaturePlugin : PluginBase
{
    public MyFeaturePlugin()
    {
        Metadata = new PluginMetadata
        {
            Id = "myfeature",
            Name = "My Feature",
            Version = "1.0.0",
            Description = "Feature description",
            Author = "Author Name",
            License = "MIT",
            Dependencies = [],
            MinimumCoreVersion = "1.0.0"
        };
    }

    protected override Task OnInitializeAsync(IPluginContext context, CancellationToken cancellationToken)
    {
        Logger?.LogInformation("My Feature plugin initialized");
        // Register services, configure features...
        return Task.CompletedTask;
    }
}
```

### Good: Interface-Based Design
```csharp
public interface ILLMModel<TInput, TOutput>
{
    Task<TOutput> GenerateAsync(
        TInput input,
        LLMOptions? options = null,
        CancellationToken cancellationToken = default);
}

public class OpenAIModel : ILLMModel<ChatMessage[], ChatMessage>
{
    // Implementation
}
```

### Good: Proper Async/Await
```csharp
public async Task<TOutput> GenerateAsync(
    TInput input,
    LLMOptions? options = null,
    CancellationToken cancellationToken = default)
{
    ArgumentNullException.ThrowIfNull(input);
    
    try
    {
        var result = await _httpClient.PostAsync(
            _endpoint,
            content,
            cancellationToken).ConfigureAwait(false);
        
        return await DeserializeAsync<TOutput>(result, cancellationToken)
            .ConfigureAwait(false);
    }
    catch (HttpRequestException ex)
    {
        _logger.LogError(ex, "Failed to call LLM API");
        throw new LLMException("LLM call failed", ex);
    }
}
```

### Good: Proper Disposal
```csharp
public class ResourceManager : IAsyncDisposable
{
    private readonly HttpClient _httpClient;
    private bool _disposed;
    
    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;
        
        _httpClient?.Dispose();
        await CleanupAsync().ConfigureAwait(false);
        _disposed = true;
    }
}
```

## Anti-Patterns to Avoid

### ❌ Don't Do This:
- Use `.Result` or `.Wait()` on async methods
- Catch and swallow exceptions silently
- Hardcode API keys or secrets
- Create circular dependencies
- Use `dynamic` types unnecessarily
- Ignore cancellation tokens
- Create memory leaks (event handlers, timers)
- Write code without tests
- Skip XML documentation
- Use `var` for unclear types in public APIs
- Forget to register plugins
- Skip plugin lifecycle management
- Ignore observability requirements

### ✅ Do This Instead:
- Use `async`/`await` properly
- Handle exceptions appropriately
- Use `ISecretsProvider`
- Follow dependency inversion
- Use strong typing
- Respect cancellation tokens
- Properly dispose resources
- Write comprehensive tests
- Document all public APIs
- Use explicit types for clarity
- Register all plugins properly
- Implement plugin lifecycle
- Integrate observability throughout

## Final Notes

- **Quality over speed**: Take time to do it right
- **Test everything**: Write tests as you code
- **Document as you go**: Don't leave documentation for later
- **Review your code**: Self-review before submitting
- **Ask for help**: Don't struggle alone, ask the team
- **Learn continuously**: Stay updated with .NET best practices
- **Plugin-first thinking**: Design features as plugins when appropriate
- **Observability by default**: Instrument everything for monitoring

---

**Remember**: We're building a world-class, enterprise-grade, open-source library. Every line of code matters. Write code you'd be proud to show to the best developers in the industry. The plugin architecture enables extensibility while maintaining quality and consistency.
