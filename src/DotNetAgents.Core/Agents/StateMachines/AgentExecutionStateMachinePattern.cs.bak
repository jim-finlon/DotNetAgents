using DotNetAgents.Agents.StateMachines;
using Microsoft.Extensions.Logging;

namespace DotNetAgents.Core.Agents.StateMachines;

/// <summary>
/// State machine patterns for agent execution lifecycle management.
/// </summary>
public static class AgentExecutionStateMachinePattern
{
    /// <summary>
    /// Creates an Agent Execution state machine pattern.
    /// Pattern: Initialized → Thinking → Acting → Observing → Thinking/Finalizing
    /// Includes error recovery: Any → Error → Initialized
    /// </summary>
    /// <typeparam name="TState">The type of the state context.</typeparam>
    /// <param name="logger">Optional logger instance.</param>
    /// <param name="maxThinkingTime">Maximum time allowed in Thinking state before transitioning to Error (default: 5 minutes).</param>
    /// <param name="maxActingTime">Maximum time allowed in Acting state before transitioning to Error (default: 2 minutes).</param>
    /// <returns>A configured state machine.</returns>
    public static IStateMachine<TState> CreateAgentExecutionPattern<TState>(
        ILogger<AgentStateMachine<TState>>? logger = null,
        TimeSpan? maxThinkingTime = null,
        TimeSpan? maxActingTime = null)
        where TState : class
    {
        var builder = new StateMachineBuilder<TState>(logger);

        var thinkingTimeoutDuration = maxThinkingTime ?? TimeSpan.FromMinutes(5);
        var actingTimeoutDuration = maxActingTime ?? TimeSpan.FromMinutes(2);

        var stateMachine = builder
            .AddState("Initialized",
                entryAction: ctx => { /* Log entering initialized state */ })
            .AddState("Thinking",
                entryAction: ctx => { /* Log entering thinking state */ })
            .AddState("Acting",
                entryAction: ctx => { /* Log entering acting state */ })
            .AddState("Observing",
                entryAction: ctx => { /* Log entering observing state */ })
            .AddState("Finalizing",
                entryAction: ctx => { /* Log entering finalizing state */ })
            .AddState("Error",
                entryAction: ctx => { /* Log error state entry */ })
            .AddTransition("Initialized", "Thinking",
                guard: ctx => true) // On execution start
            .AddTransition("Thinking", "Acting",
                guard: ctx => true) // On tool selection
            .AddTransition("Acting", "Observing",
                guard: ctx => true) // On tool execution complete
            .AddTransition("Observing", "Thinking",
                guard: ctx => true) // On observation complete, continue thinking
            .AddTransition("Observing", "Finalizing",
                guard: ctx => true) // On final answer ready
            .AddTransition("Thinking", "Finalizing",
                guard: ctx => true) // Direct finalization from thinking (no tools needed)
            // Error transitions from any state
            .AddTransition("Initialized", "Error",
                guard: ctx => true) // On exception
            .AddTransition("Thinking", "Error",
                guard: ctx => true) // On exception
            .AddTransition("Acting", "Error",
                guard: ctx => true) // On exception
            .AddTransition("Observing", "Error",
                guard: ctx => true) // On exception
            .AddTransition("Finalizing", "Error",
                guard: ctx => true) // On exception
            // Recovery from error (return to Initialized to restart)
            .AddTransition("Error", "Initialized",
                guard: ctx => true) // After recovery
            .SetInitialState("Initialized")
            .Build();

        // Add timeout transitions
        if (stateMachine is AgentStateMachine<TState> agentStateMachine)
        {
            // Thinking timeout: Thinking → Error (max thinking time exceeded)
            agentStateMachine.AddTimeoutTransition("Thinking", "Error", thinkingTimeoutDuration);
            
            // Acting timeout: Acting → Error (tool execution timeout)
            agentStateMachine.AddTimeoutTransition("Acting", "Error", actingTimeoutDuration);
        }

        return stateMachine;
    }
}
